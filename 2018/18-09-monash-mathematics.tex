\documentclass[presentation]{beamer}

\usepackage{tikz}
\usetikzlibrary{trees,calc}
\usepackage{booktabs}
\usepackage{pgf}
\usepackage{pgfplots}
\pgfplotsset{compat=1.13}
\usepackage{pgfplotstable}
\usepackage{appendixnumberbeamer}
\usepackage{amsmath}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\DeclareMathOperator{\grad}{grad}
\DeclareMathOperator{\tr}{tr}
\let\div\relax
\DeclareMathOperator{\div}{div}
\DeclareMathOperator{\curl}{curl}
\date{18th September 2018}
\usetheme{metropolis}
\metroset{progressbar=frametitle}

\usepackage{algpseudocode}
\renewcommand{\vec}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\ddt}[1]{\frac{\partial #1}{\partial t}}
\newcommand{\zhat}{\hat{\vec{z}}}
\newcommand{\W}{\ensuremath{\mathbb{W}}}

\newcommand{\inner}[1]{\left\langle #1 \right \rangle}

\newcommand{\KSP}[2]{\ensuremath{\mathcal{K}\left(#1, \mathbb{#2}\right)}}
\newcommand{\ksp}[1]{\KSP{#1}{#1}}

\newcommand{\highlight}[1]{\colorbox{red!20}{\color{black} #1}}
\newcommand{\arxivlink}[2]{%
  \href{http://www.arxiv.org/abs/#1}%
  {\texttt{arXiv:\,#1\,[#2]}}%
}
\newcommand{\doilink}[1]{%
  \href{http://dx.doi.org/#1}%
  {\texttt{doi:\,#1}{}}%
}

\author{Lawrence Mitchell\inst{1,*} \\ {\scriptsize C.J.~Cotter,
    P.E.~Farrell, D.A.~Ham, M.~Homolya, P.H.J.~Kelly, R.C.~Kirby, F.~Wechsung \ldots}}
\institute{
\inst{1}Department of Computer Science, Durham University

\inst{*}\texttt{lawrence.mitchell@durham.ac.uk}
}

\graphicspath{{./\jobname.figures/}{../pictures/}}

\usepackage[url=false,
doi=true,
isbn=false,
style=authoryear,
giveninits=true,
uniquename=init,
backend=biber]{biblatex}

\usepackage{xspace}
\renewcommand{\Re}{\ensuremath{\mathrm{Re}}\xspace}
\newcommand{\honev}{\ensuremath{{H}^1(\Omega; \mathbb{R}^d)}\xspace}
\newcommand{\ltwov}{\ensuremath{{L}^2(\Omega; \mathbb{R}^d)}\xspace}
\newcommand{\ltwo}{\ensuremath{{L}^2(\Omega)}\xspace}
\newcommand{\laplace}{\ensuremath{\Delta}\,}
\newcommand{\hess}{\ensuremath{\mathbf{hessian}}\,}
\newcommand{\rt}{\ensuremath{\mathrm{RT}_0}\xspace}
\newcommand{\nd}{\ensuremath{\mathrm{ND}_0}\xspace}
\newcommand{\kerdiv}{\ensuremath{\mathrm{ker}(\mathbf{div})}\xspace}
\newcommand{\kercurl}{\ensuremath{\mathrm{ker}(\mathbf{curl})}\xspace}
\newcommand{\eker}{\ensuremath{e^{\mathrm{ker}}}\xspace}
\newcommand{\ds}{\ \mathrm{d}s}
\newcommand{\dx}{\ \mathrm{d}x}
\newcommand{\Pq}{\ensuremath{\mathrm{P}_{Q_h}}}
\newcommand{\PqK}{\ensuremath{\mathrm{P}_{Q_h(K)}}}
\newcommand{\Ptwo}{\ensuremath{\mathbb{P}_2}\xspace}
\newcommand{\Pthree}{\ensuremath{\mathbb{P}_3}\xspace}
\newcommand{\PtwoPzero}{\ensuremath{[\mathbb{P}_2]^2\mathrm{-}\mathbb{P}_0}\xspace}
\newcommand{\PthreePzero}{\ensuremath{[\mathbb{P}_3]^3\mathrm{-}\mathbb{P}_0}\xspace}
\newcommand{\Pzero}{\ensuremath{\mathbb{P}_0}\xspace}
\newcommand{\Pv}{\ensuremath{\mathbb{P}_v}\xspace}
\newcommand{\BR}{\ensuremath{\left(\mathbb{P}_1 \oplus B^F_3\right)}\xspace}
\newcommand{\PoneFB}{\ensuremath{\mathbb{P}_1 \oplus B^F_3}\xspace}
\newcommand{\PtwoFB}{\ensuremath{\mathbb{P}_2 \oplus B^F_3}\xspace}
\newcommand{\BRzero}{\ensuremath{\BR^3\mathrm{-}\mathbb{P}_0}\xspace}
\newcommand{\fmw}{\ensuremath{\left(\mathbb{P}_2 \oplus B^F_3\right)}\xspace}
\newcommand{\fmwzero}{\ensuremath{\fmw^3\mathrm{-}\mathbb{P}_0}\xspace}
%\newcommand{\advect}[2]{\ensuremath{(\nabla #1) \cdot #2}}
\newcommand{\advect}[2]{\ensuremath{(#2 \cdot \nabla) #1}}
\newcommand{\mesh}{\ensuremath{\mathcal{M}}\xspace}
\newcommand{\Ac}{\ensuremath{\mathcal{A}}}
\newcommand{\Bc}{\ensuremath{\mathcal{B}}}
\setbeamertemplate{bibliography item}{}

\renewcommand{\bibfont}{\fontsize{7}{7}\selectfont}
\addbibresource{references.bib}

\setlength{\bibitemsep}{1ex}
\setlength{\fboxsep}{1pt}

\renewbibmacro{in:}{}
\DeclareFieldFormat[article]{volume}{\textbf{#1}}
\DeclareFieldFormat{doi}{%
  doi\addcolon%
  {\scriptsize\ifhyperref{\href{http://dx.doi.org/#1}{\nolinkurl{#1}}}
    {\nolinkurl{#1}}}}
\AtEveryBibitem{%
\clearfield{pages}%
\clearfield{issue}%
\clearfield{number}%
}

\usepackage{minted}
\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}


\title{From symbolic mathematics to fast solvers for finite element problems}

\begin{document}

\maketitle

% \begin{abstract}
%   One of the great and enduring successes of numerical computing is
%   the capturing of mathematical abstractions in software.  This allows
%   the programmer to express the intent of their code, without
%   specifying its low-level implementation.  We then automate the
%   synthesis of efficient code by using (or writing) compilers.

%   In the context of solving numerical PDEs, the finite element method
%   is particularly amenable to this approach.  For many problems, the
%   choice of discretisation completely specifies the mathematical
%   intent.  A symbolic description of the PDE can then be manipulated
%   by a domain-specific compiler to produce a high-performance
%   implementation.

%   In this talk, I will present a concrete realisation of these ideas,
%   embodied in the finite element software Firedrake
%   (www.firedrakeproject.org).  I will discuss how capturing and
%   exploiting symbolic structure in numerical software greatly
%   simplifies model development, while simultaneously permitting the
%   synthesis of a high performance implementation.

%   I will then discuss recent work extending these same ideas to the
%   development of preconditioners, illustrating with some recent work
%   on scalable solvers for the three-dimensional stationary
%   Navier-Stokes equations.
% \end{abstract}

% People:
% Jerome Droniou
% Michael Page
% Hans de Sterck
% Philip Hall
% Steve Siems
% Yann Bernard
% Simon Clarke
% Julie Clutterbuck
% Anja Slim
% Kengo Deguchi
% Christian Thomas

\begin{frame}
  \frametitle{Outline}

  25 + 5 minutes

  - Finite elements
  - Code that matches maths
  - Compilers for this code
  - Cover sum factorisation
  - Hybridisation methods

  - Navier-Stokes
  - Augmented Lagrangian
  - Multigrid requires characterisation of kernel of div
  - New: extension of scheme to 3D
  - Full Newton
  - Scalability results
  - Future direction H(div)/Scott-Vogelius
\end{frame}

\begin{frame}
  \frametitle{Finite elements for PDEs}
  \begin{align*}
    F(u) &= 0 \text{ in $\Omega$}\\
    u &= g \text{ on $\Gamma_1$}\\
    \frac{\partial u}{\partial n} &= h \text{ on $\Gamma_2$}
  \end{align*}
  Seek weak solution in some space of functions $V(\Omega)$.

  Now we need to solve the (infinite dimensional) problem, find $u\in V$ s.t.
  \begin{equation*}
    \int_\Omega \!F(u) v\, \text{d}x = 0 \quad \forall\, v \in V
  \end{equation*}
\end{frame}
\begin{frame}
  \frametitle{Finite element crash course}
  Choose finite dimensional $V_h \subset V$, and seek a solution in
  that subspace: find $u_h \in V_h$ s.t.
  \begin{equation*}
    \int_\Omega \!F(u_h) v_h\, \text{d}x = 0 \quad \forall\, v_h \in V_h
  \end{equation*}
\end{frame}
\begin{frame}
  \frametitle{Finite element crash course}
  \begin{overprint}
    \only<1>{Divide domain $\Omega$\dots
    \begin{center}
      \begin{tikzpicture}
        \draw[very thick, line cap=rect] (0,0) -- (5, 0) (0, 0) arc
        (180:360:2.5);
      \end{tikzpicture}
    \end{center}}
  \only<2>{\dots{}into triangulation $\mathcal{T}$\dots
    \begin{center}
        \begin{tikzpicture}
          \path (0,0) arc[radius=2.5, start angle=180, end angle=360]
          node[name=E,pos=0,swap] {} node[name=F,pos=0.25,swap] {}
          node[name=G,pos=0.5,swap] {} node[name=H,pos=0.82,swap] {}
          node[name=I,pos=1,swap] {}; \node (A) at (2.5, 0) {}; \node
          (B) at (1.4, -0.7) {}; \node (C) at (3.4, -1.2) {}; \node
          (D) at (1.8, -1.5) {};

          \draw[color=black, very thick, line cap=butt, line
          join=round] (E.center) -- (A.center) -- (I.center) --
          (H.center) -- (G.center) -- (F.center) -- (E.center) --
          cycle; \draw[color=black, very thick, line cap=butt, line
          join=round] (E.center) -- (B.center) -- (D.center) --
          (F.center) -- (B.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (G.center) -- (D.center) --
          (C.center) -- (G.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (B.center) -- (A.center) --
          (C.center) -- (B.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (H.center) -- (C.center) --
          (I.center);
        \end{tikzpicture}
    \end{center}
  }
  \only<3>{\dots{}and choose basis with finite support.
    \begin{center}
        \begin{tikzpicture}
          \path (0,0) arc[radius=2.5, start angle=180, end angle=360]
          node[name=E,pos=0,swap] {} node[name=F,pos=0.25,swap] {}
          node[name=G,pos=0.5,swap] {} node[name=H,pos=0.82,swap] {}
          node[name=I,pos=1,swap] {}; \node (A) at (2.5, 0) {}; \node
          (B) at (1.4, -0.7) {}; \node (C) at (3.4, -1.2) {}; \node
          (D) at (1.8, -1.5) {};

        \path[fill=gray!50] (E.center) -- (A.center) -- (B.center) --
        (F.center) --cycle;
          \draw[color=black, very thick, line cap=butt, line
          join=round] (E.center) -- (A.center) -- (I.center) --
          (H.center) -- (G.center) -- (F.center) -- (E.center) --
          cycle; \draw[color=black, very thick, line cap=butt, line
          join=round] (E.center) -- (B.center) -- (D.center) --
          (F.center) -- (B.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (G.center) -- (D.center) --
          (C.center) -- (G.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (B.center) -- (A.center) --
          (C.center) -- (B.center); \draw[color=black, very thick,
          line cap=butt, line join=round] (H.center) -- (C.center) --
          (I.center);
        \end{tikzpicture}
      \end{center}
      }
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{Finite element crash course}
  Integrals become sum over element integrals
  \begin{equation*}
    \int_\Omega\! F(u_h) v_h \, \text{d}x =
    \sum_{e \in \mathcal{T}} \int_e\! F(u_h)v_h\, \text{d}x
  \end{equation*}

  (Usually) perform element integrals with numerical quadrature
  \begin{equation*}
    \int_e F(u_h)v_h\,\text{d}x = \sum_q w_q F(u_h(q)) v_h(q)\,\text{d}x
  \end{equation*}

  Replace $u_h(q), v_h(q)$ with expansion in finite element basis
  \begin{align*}
    u_h(q) &= \sum_i u_h^i \phi_i(q)\\
    v_h(q) &= \phi_j(q)\\
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{Abstractly}
  \begin{itemize}
  \item Mathematics says ``here is the integral to compute on each
    element, do that everywhere''
  \item Doesn't specify \emph{how} to compute the integral
  \item Doesn't specify \emph{how} to gather the element contributions
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Compilers for finite elements}
  \begin{block}{Assertion}
    Once we pick the discretisation, writing the element integral is mechanical.
  \end{block}
  \begin{corollary}
    Computers are good at mechanical things, why don't we get the
    computer to write the element integral?
  \end{corollary}
\end{frame}

\begin{frame}
  \frametitle{Firedrake \url{www.firedrakeproject.org}}

  \begin{quote}
    {\normalfont [\ldots]} an automated system for the solution of partial
    differential equations using the finite element method.
  \end{quote}

  \begin{onlyenv}<1>
    \begin{itemize}
    \item Written in Python.
    \item Finite element problems specified with \emph{embedded}
      domain specific language, UFL \parencite{Alnaes:2014} from the
      FEniCS project.
    \item \emph{Runtime} compilation to low-level (C) code.
    \item Explicitly \emph{data parallel} API.
    \end{itemize}

    \begin{flushright}
      {\scriptsize F.~Rathgeber, D.A.~Ham, \textbf{LM}, M.~Lange,
        F.~Luporini, A.T.T.~McRae, G.-T.~Bercea, G.R.~Markall,
        P.H.J.~Kelly. TOMS,
        2016. \arxivlink{1501.01809}{cs.MS}\nocite{Rathgeber:2016}}
    \end{flushright}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{block}{User groups at}
      Imperial, Oxford, Bath, Leeds, Kiel, Rice, Houston, Exeter, Buffalo,
      Waterloo, Minnesota, Baylor, Texas A\&M, \dots
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{An example}
  \begin{columns}
    \begin{column}{0.47\framewidth}
      {\footnotesize
        Find $(u, p, T) \in V\times W\times Q$ s.t.
        \begin{align*}
          \int\!\nabla u \cdot \nabla v + (u \cdot \nabla u) \cdot v \\
          - p\nabla\cdot v + \frac{\text{Ra}}{\text{Pr}} Tg \hat{z} \cdot v\,\text{d}x &= 0 \\
          \int\!\nabla\cdot u q\,\text{d}x&= 0\\
          \int\! (u\cdot \nabla T) S + \text{Pr}^{-1} \nabla T \cdot \nabla
          S\,\text{d}x &= 0\\
          \quad \forall\, (v,q,T) \in V\times W \times Q
        \end{align*}
        }
    \end{column}
      \begin{column}{0.52\framewidth}
\begin{minted}[fontsize=\tiny]{python}
from firedrake import *
mesh = Mesh(...)
V = VectorFunctionSpace(mesh, "CG", 2)
W = FunctionSpace(mesh, "CG", 1)
Q = FunctionSpace(mesh, "CG", 1)
Z = V * W * Q
Ra = Constant(...)
Pr = Constant(...)
upT = Function(Z)
u, p, T = split(upT)
v, q, S = TestFunctions(Z)
bcs = [...]

F = (inner(grad(u), grad(v))
     + inner(dot(grad(u), u), v)
     - inner(p, div(v))
     + (Ra/Pr)*inner(T*g, v)
     + inner(div(u), q)
     + inner(dot(grad(T), u), S)
     + (1/Pr) * inner(grad(T), grad(S)))*dx

solve(F == 0, upT, bcs=bcs)
\end{minted}
      \end{column}
  \end{columns}
\end{frame}


\section{Addressing the solver issue}
\begin{frame}
  \frametitle{Navier-Stokes}
Find $(u, p) \in \honev \times \ltwo$ such that
\begin{alignat*}{2}
  -  \nu \nabla^2 u + \advect{u}{u} + \nabla p &= f \quad && \text{ in } \Omega, \label{eqn:momentum} \\
  \nabla \cdot u &= 0 \quad && \text{ in } \Omega, \\
  u &= g \quad && \text{ on } \Gamma_D, \\
  \nu \nabla u \cdot n &= pn \quad && \text{ on } \Gamma_N,
\end{alignat*}
\end{frame}

\begin{frame}
  \frametitle{Linear saddle point system}
  After Newton linearization and choosing a spatial discretisation
\begin{equation} \label{eqn:sp}
\begin{pmatrix}
A & B^T \\
B & 0
\end{pmatrix}
\begin{pmatrix}
\delta u \\ \delta p
\end{pmatrix}
=
\begin{pmatrix}
b \\ 0
\end{pmatrix},
\end{equation}

Challenge: computing inverse.

Augmented Lagrangian scheme

\begin{equation} \label{eqn:spal}
\begin{pmatrix}
A + \gamma B^T M_p^{-1} B & B^T \\
B & 0
\end{pmatrix}
\begin{pmatrix}
\delta u \\ \delta p
\end{pmatrix}
=
\begin{pmatrix}
b \\ 0
\end{pmatrix},
\end{equation}

\begin{equation} \label{eqn:schur}
S^{-1} \approx (\nu + \gamma) M_p^{-1},
\end{equation}
Challenge: $\nu$ and $\gamma$ independent PC for $A + \gamma B^T
M_p^{-1} B$.  We take $\gamma$ large.
\end{frame}

\begin{frame}
  \frametitle{Multilevel solver}

  \resizebox{\textwidth}{!}{
  \begin{tikzpicture}[
  every node/.style={draw=black, thick, anchor=west},
  grow via three points={one child at (0.0,-0.7) and
  two children at (0.0,-0.7) and (0.0,-1.4)},
  edge from parent path={(\tikzparentnode.210) |- (\tikzchildnode.west)}]
  \node {Continuation}
    child { node {Newton solver with line search}
      child { node {Krylov solver (FGMRES)}
        child { node {Block preconditioner}
          child { node {Approximate Schur complement inverse}}
          child { node {F-cycle on augmented momentum block}
              child { node {Coarse grid solver}
                child { node {LU factorization on assembled matrix}}
              }
              child [missing] {}
              child { node {Prolongation operator}
                child { node {Local solves over coarse cells}}
              }
              child [missing] {}
              child { node {Relaxation}
                child { node {GMRES}
                  child { node {Matrix-free additive star iteration}}
                }
              }
          }
        }
      }
    };
  \end{tikzpicture}
  }
\end{frame}

\begin{frame}
  \frametitle{$A_\gamma$ preconditioner}
  Pieces:

  Smoother that is robust wrt $\nu$ and $\gamma$, requires subspace
  decomposition
  \begin{equation*}
    \mathcal{N} = \sum_i \left(V_i \cap \mathcal{N} \right)
  \end{equation*}
  \begin{equation*}
    \mathcal{N} := \{u \in V : (\Pq \nabla \cdot u, \nabla \cdot v) =
    0 \ \forall\ v \in V\}
  \end{equation*}
  \begin{equation*}
    V = \sum_i V_i
  \end{equation*}

  Kernel is spanned by basis functions with local support around each
  vertex.

  Relaxation scheme: \emph{star iteration} (Also used for robust
  multigrid in $H(\text{div}/\text{curl})$ (AFW 2000).
\end{frame}

\begin{frame}
  \frametitle{Prolongation}
  Need to preserve kernel of Pdiv in prolongation.

  Natural embedding does not do this.

  Solve local Stokes problem on each coarse cell to fix things up.

  P3-P0 expensive.

  P1+FB-P0: inf-sup (via BR)

  Now prolongation is not nested: preserve flux by scaling.
\end{frame}

\begin{frame}
  \frametitle{Software abstractions}
  Schwarz building blocks:

  Subspace decomp
  Operators on subspaces
  Solvers on subspaces
  Coarse spaces (not yet)

  Separate topological decomposition with callback interface for operators
\end{frame}
\begin{frame}
  \frametitle{Flexible selection of patches}
  Star patches animation

  Coarse cell patch animation.

  Operators just by doing finite element assembly
\end{frame}
\begin{frame}
  \frametitle{Results: 3D lid-driven cavity}
  \begin{onlyenv}<1>
    Reynolds number robust convergence.
    \begin{center}
      \begin{tabular}{cc|ccccc}
        \toprule
        \# refinements & \# dofs & \multicolumn{5}{c}{Reynolds number} \\
                       && 10 & 100 & 1000 & 2500 & 5000 \\
        \midrule
        1 & $2.1 \times 10^6$ & 7.50 & 7.33 & 7.50 & 7.00 & 6.50 \\
        2 & $1.7 \times 10^7$ & 8.50 & 7.00 & 7.50 & 6.50 & 5.50 \\
        3 & $1.3 \times 10^8$ & 7.00 & 7.00 & 6.50 & 5.00 & 6.50 \\
        4 & $1.1 \times 10^9$ & 7.00 & 7.33 & 5.50 & 4.00 & 9.00 \\
        \bottomrule
      \end{tabular}
    \end{center}
  \end{onlyenv}
  \begin{onlyenv}<2>
    
    \begin{center}
      \pgfplotstableread[col sep=comma, row sep=\\]{%
        Cores,Time,Dofs\\
        48,1.91e2,2134839\\
        384,2.52e2,16936779\\
        3072,2.3e2,134930451\\
        24576,2.55e2,1077196323\\
      }\datatable
      \begin{tikzpicture}[scale=0.8]
        \begin{semilogxaxis}[
          log basis x=2,
          ymin=0,
          xtick=data,
          xticklabels from table={\datatable}{Cores},
          extra x ticks={48, 384, 3072, 24576},
          extra x tick labels={$[2.13]$, $[16.9]$,$[135]$,$[1077]$},
          extra x tick style={tick label style={yshift=-2ex}},
          xlabel={Cores\\{}[DoFs $\times 10^6$]},
          xlabel style={align=center},
          ylabel near ticks,
          ylabel style={align=center, text width=4cm},
          ylabel={Time to solution over all continuation steps [min]},
          title style={align=center, text width=7cm},
          ]
          \addplot+ table[x=Cores,y=Time] {\datatable};
        \end{semilogxaxis}
      \end{tikzpicture}
    \end{center}
  \end{onlyenv}
\end{frame}

\begin{frame}
  \frametitle{Future directions}

  This problem:
  Better discretisation

  Options: Scott-Vogelius

  H(div)-L2 with penalty scheme for diffusion operator (potential for
  non-nested mesh hierarchies)

  Technology:
  Nonlinear schwarz; FAS smoothers.
\end{frame}
\end{document}
