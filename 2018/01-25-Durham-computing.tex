\documentclass[presentation]{beamer}

\usepackage{tikz}
\usetikzlibrary{positioning,calc,matrix}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes}
\usetikzlibrary{backgrounds}% only to show the bounding box
\usepackage{pgf}
\usepackage{pgfplots}
\pgfplotsset{compat=1.13}
\usepackage{pgfplotstable}
\usepackage{appendixnumberbeamer}
\usepackage{amsmath}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\grad}{grad}
\let\div\relax
\DeclareMathOperator{\div}{div}
\DeclareMathOperator{\curl}{curl}
\date{25th January 2018}
\usetheme{metropolis}
\metroset{progressbar=frametitle}

\usepackage{algpseudocode}
\renewcommand{\vec}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\ddt}[1]{\frac{\partial #1}{\partial t}}
\newcommand{\zhat}{\hat{\vec{z}}}
\newcommand{\W}{\ensuremath{\mathbb{W}}}

\newcommand{\inner}[1]{\left\langle #1 \right \rangle}

\newcommand{\KSP}[2]{\ensuremath{\mathcal{K}\left(#1, \mathbb{#2}\right)}}
\newcommand{\ksp}[1]{\KSP{#1}{#1}}

\newcommand{\highlight}[1]{\colorbox{red!20}{\color{black} #1}}
\newcommand{\arxivlink}[2]{%
  \href{http://www.arxiv.org/abs/#1}%
  {\texttt{arXiv:\,#1\,[#2]}}%
}
\newcommand{\doilink}[1]{%
  \href{http://dx.doi.org/#1}%
  {\texttt{doi:\,#1}{}}%
}

\author{Lawrence Mitchell\inst{1,*} \\ {\scriptsize C.J.~Cotter,
    D.A.~Ham, M.~Homolya, T.~K\"arn\"a, P.H.J.~Kelly, R.C.~Kirby, E.H.~M\"uller, \ldots}}
\institute{
\inst{1}Departments of Computing and Mathematics, Imperial College
London

\inst{*}\texttt{lawrence.mitchell@imperial.ac.uk}
}

\graphicspath{{./\jobname.figures/}{../pictures/}}

\usepackage[url=false,
            doi=true,
            isbn=false,
            style=authoryear,
            giveninits=true,
            uniquename=init,
            backend=biber]{biblatex}

\setbeamertemplate{bibliography item}{}

\renewcommand{\bibfont}{\fontsize{7}{7}\selectfont}
\addbibresource{../literature.bib}

\setlength{\bibitemsep}{1ex}
\setlength{\fboxsep}{1pt}

\renewbibmacro{in:}{}
\DeclareFieldFormat[article]{volume}{\textbf{#1}}
\DeclareFieldFormat{doi}{%
  doi\addcolon%
  {\scriptsize\ifhyperref{\href{http://dx.doi.org/#1}{\nolinkurl{#1}}}
    {\nolinkurl{#1}}}}
\AtEveryBibitem{%
\clearfield{pages}%
\clearfield{issue}%
\clearfield{number}%
}

\usepackage{minted}
\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}

\title{Symbolic numerical computing}
\begin{document}
\begin{frame}[plain,noframenumbering]
  \maketitle
  \begin{tikzpicture}[remember picture,overlay]
    \node[at=(current page.south west), anchor=south west] {\includegraphics[height=0.9cm]{epsrc-logo}};
  \node[at=(current page.south east), anchor=south east] {\includegraphics[height=0.9cm]{imperial-two-tone}};
\end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Outline}

  \begin{itemize}
  \item Overview of some recent research
    \begin{itemize}
    \item Fast solvers for numerical weather prediction
    \item Automated finite elements
    \end{itemize}
  \item In depth
    \begin{itemize}
    \item Compiling finite element problems
    \end{itemize}
  \item Future directions
  \end{itemize}
\end{frame}

\section{Recent highlights}
\begin{frame}
  \frametitle{Numerical weather prediction}
  \begin{columns}
    \begin{column}{3cm}
      \includegraphics[width=3cm]{earth}
    \end{column}
    \begin{column}{6cm}
      {\footnotesize \begin{equation*}
          \begin{pmatrix}
            M_2 & -\frac{\Delta t}{2}D^T &
            -\frac{\Delta t}{2}Q\\[1ex]
            \frac{\Delta t}{2}c^2D & M_3 & 0\\[1ex]
            \frac{\Delta t}{2}N^2Q^T & 0 & M_b
          \end{pmatrix}
          \begin{pmatrix}
            \vec{U}\\[1ex]\vec{P}\\[1ex]\vec{B}
          \end{pmatrix}
          =
          \begin{pmatrix}
            M_2\vec{R}_u\\[1ex]
            M_3\vec{R}_p\\[1ex]
            M_b\vec{R}_b
          \end{pmatrix}
        \end{equation*}}
    \end{column}
  \end{columns}
  \begin{block}{Challenge}
    Invert elliptic operator fast enough for operational forecasting.

    High aspect ratio: black-box numerical solvers struggle.

    Need scalable, custom multigrid solver.
  \end{block}
\end{frame}
\begin{frame}
  \frametitle{Multigrid approach}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{tikzpicture}
        \node (B) {\includegraphics[height=1.5cm]{bandedmatrix}}; \node
        (C) [right=0.15cm of B,yshift=0.6cm]
        {\includegraphics[height=1cm]{columndofs}}; \node (A)
        [below=0.05cm of C]
        {\includegraphics[height=0.75cm]{MeshHierarchy}};
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.4\textwidth}
      \includegraphics[width=4cm]{nwp-multigrid-scaling}
    \end{column}
  \end{columns}
    Developed custom tensor-product multigrid scheme, showed robustness
    and scalability.

  \begin{block}{Research impact}
    Approach is used by UK Met Office in their next generation dynamical
    core.

    Providing a weather forecast to you in 2025.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Automated finite elements}
  \begin{block}{Challenge}
  \begin{itemize}
  \item Simulation software needs to exploit \emph{fine-grained}
    parallelism.
  \item Most code intimately intertwines the numerical algorithm with
    its \emph{implementation}.
  \item To apply program transformations, we have to unpick,
    understand, and reimplement.
  \item \emph{Every time} the hardware changes.
  \item Most researchers do not have the skills necessary to be
    application and HPC experts.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Firedrake \url{www.firedrakeproject.org}}
  \begin{quote}
    {\normalfont [\ldots]} an automated system for the solution of
    partial differential equations using the finite element method.
  \end{quote}
  \begin{itemize}
  \item Written in Python.
  \item Finite element problems specified with embedded domain
    specific language.
  \item Domain-specific optimising compiler.
  \item Runtime compilation to low-level (C) code.
  \item Transparently parallel.
  \end{itemize}
  \begin{flushright}
    {\scriptsize F.~Rathgeber, D.A.~Ham, \textbf{LM}, M.~Lange,
      F.~Luporini, A.T.T.~McRae, G.-T.~Bercea, G.R.~Markall,
      P.H.J.~Kelly. ACM Transactions on Mathematical Software,
      2016. \arxivlink{1501.01809}{cs.MS}}
  \end{flushright}
\end{frame}
\begin{frame}
  \frametitle{Highlights}
  \begin{itemize}
  \item Dramatically simplifies numerical model development.  Often
    from months/years to days/weeks.
  \item Delivers ``better than most humans'' computational
    performance.
  \item New code separates mathematics from implementation.  More
    portable to future architectures.
  \item \emph{Enables} productive interdisciplinary collaboration.
  \end{itemize}

  \begin{block}{Future research direction}
    \begin{itemize}
    \item Code transformations for efficient execution on GPUs
    \end{itemize}
  \end{block}
\end{frame}
\begin{frame}
  \frametitle{Impact \& use}
  \begin{block}{Academic}
    \begin{itemize}
    \item Used by research groups at Imperial, Baylor, Kiel, Exeter,
      Oxford, Leeds, Waterloo, Buffalo, Washington, \ldots

    \item Teaching tool at Waterloo, Imperial.
    \end{itemize}
  \end{block}
  \begin{block}{Industrial}
    \begin{itemize}
    \item Guides design of computational and numerical schemes in UK
      Met Office's next forecasting system.

    \item Optimisation of tidal turbine array placement.
    \end{itemize}
  \end{block}
\end{frame}

\section{Compiling finite element problems}

\begin{frame}[fragile]
  \frametitle{Exploit mathematical abstractions}
  Compute $y \leftarrow \nabla^2 x$ using finite differences.
  \begin{equation*}
    y_{i,j} = x_{i-1, j} + x_{i+1, j} + x_{i, j-1} + x_{i, j+1} - 4x_{i,j}    
  \end{equation*}
  \begin{overlayarea}{\textwidth}{0.8\textheight}
  \begin{onlyenv}<1>
    \begin{block}{Before 1953}
      \vspace{1em}
      \begin{columns}
        \begin{column}{0.5\textwidth}
\begin{minted}[fontsize=\tiny]{asm}
        ...
        faddp   %st, %st(1)
        movl    -8(%ebp), %edx
        movl    %edx, %eax
        sall    $2, %eax
        addl    %edx, %eax
        leal    0(,%eax,4), %edx
        addl    %edx, %eax
        sall    $2, %eax
        movl    %eax, %edx
        movl    -4(%ebp), %eax
        addl    %edx, %eax
        subl    $101, %eax
        flds    x.3305(,%eax,4)
        flds    .LC0
        fmulp   %st, %st(1)
        faddp   %st, %st(1)
        fstps   y.3307(,%ecx,4)
        ...
\end{minted}
        \end{column}
        \begin{column}{0.5\textwidth}
          \begin{tikzpicture}
            \node[draw,rectangle, thick, text width=1in, align=center]
            (A) {\small Pen and paper};
            \node[draw, below=3cm of A, rectangle, thick, text width=1in, align=center]
            (C) {\small Machine code};
            \draw[-stealth] (A) -> (C) node [midway,right,text width=1in,align=center]
            {\small Manual};
          \end{tikzpicture}
        \end{column}
      \end{columns}
    \end{block}
    % Picture: pen-and-paper -> machine code
  \end{onlyenv}
  \begin{onlyenv}<2->
    \begin{block}{1953--present: Formula Translation}
      \vspace{1em}
      \begin{columns}
        \begin{column}{0.5\textwidth}
\begin{minted}[fontsize=\tiny]{fortran}
      PROGRAM MAIN
      PARAMETER (N=100)
      REAL X(N,N), Y(N,N)
      [...]
      DO 10 J=2,N-1
         DO 20 I=2,N-1
            Y(I,J)=X(I-1,J)+X(I+1,J)+
     $           X(I,J-1)+X(I,J+1)+4*X(I,J)
 20      CONTINUE
 10   CONTINUE
      [...]
      END
\end{minted}
        \end{column}
        \begin{column}{0.5\textwidth}
          \begin{tikzpicture}
            \node[draw,rectangle, thick, text width=1in, align=center]
            (A) {\small Pen and paper};
            \node[draw, below=of A, rectangle, thick, text width=1in, align=center]
            (B) {\small Low-level code};
            \node[draw, below=of B, rectangle, thick, text width=1in, align=center]
            (C) {\small Machine code};
            \draw[-stealth] (A) -> (B) node [midway,right,text width=1in,align=center]
            {\small Manual};
            \draw[-stealth] (B) -> (C) node [midway,right,text width=1in,align=center]
            {\small Automated};
          \end{tikzpicture}
        \end{column}
      \end{columns}
    \end{block}
  \end{onlyenv}
  \end{overlayarea}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fit to the mathematics}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{equation*}
        a(u, v) = \int_\Omega \nabla u \cdot \nabla v\,\text{d}x \quad \forall v \in V
      \end{equation*}
\begin{minted}[fontsize=\scriptsize]{python}
V = FiniteElement("Lagrange", 
                  triangle, 1)
u = TrialFunction(V)
v = TestFunction(V)
F = dot(grad(u), grad(v))*dx
\end{minted}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{tikzpicture}
        \node[draw,rectangle, thick, text width=1in, align=center]
        (A) {\small Pen and paper}; \node[draw, below=of A,
        rectangle, thick, text width=1in, align=center] (B) {\small
          High-level code}; \node[draw, below=of B, rectangle,
        thick, text width=1in, align=center] (C) {\small Low-level
          code}; \node[draw, below=of C, rectangle, thick, text
        width=1in, align=center] (D) {\small Machine code};
        \draw[-stealth] (A) -> (B) node [midway,right,text
        width=1in,align=center] {\small Manual}; \draw[-stealth] (B)
        -> (C) node [midway,right,text width=1in,align=center]
        {\small Automated}; \draw[-stealth] (C) -> (D) node
        [midway,right,text width=1in,align=center] {\small
          Automated};
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{TSFC: an optimising compiler for finite elements}
  Translate UFL into low-level code for performing an element integral.
  \begin{flushright}
    {\scriptsize M.~Homolya, \textbf{LM}, F.~Luporini, D.A.~Ham. \arxivlink{1705.03667}{cs.MS}}
  \end{flushright}
  \begin{overlayarea}{\textwidth}{0.8\textheight}
  \begin{onlyenv}<1> 
    \begin{itemize}
    \item Element integral
      \begin{columns}
        \begin{column}{0.4\textwidth}
          \begin{equation*}
            \int_e \nabla u \cdot \nabla v\,\text{d}x
          \end{equation*}
        \end{column}
        \hspace{-3em}
        \begin{column}{0.6\textwidth}
\begin{minted}[fontsize=\scriptsize]{python}
V = FiniteElement("Lagrange", triangle, 1)
u = TrialFunction(V)
v = TestFunction(V)
a = dot(grad(u), grad(v))*dx
\end{minted}
        \end{column}
      \end{columns}
    \item Is transformed to a tensor algebra expression
      {\small \begin{equation*}
    \sum_q w_q \left| d \right| \sum_{i_5} \left( \sum_{i_3}
      K_{i_3,i_5} \begin{bmatrix}
        E^{(1)}_{q,k} & E^{(2)}_{q,k}
      \end{bmatrix}_{i_3} \right)
    \left( \sum_{i_4} K_{i_4,i_5} \begin{bmatrix}
        E^{(1)}_{q,j} & E^{(2)}_{q,j}
      \end{bmatrix}_{i_4} \right)
  \end{equation*}}
\item Multiple optimisation passes aim to minimise FLOPs required to
  evaluate this expression.
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{columns}
      \begin{column}{0.5\textwidth}
\begin{minted}[fontsize=\tiny]{c}
void cell_integral(double A[3][3],
                   double coords[3][2]) {
  static const double t10[3] = {...};
  static const double t12[3] = {...};
  double t13[3];
  double t14[3];
  double t0 = (-1 * coords[0][1]);
  double t1 = (t0 + coords[1][1]);
  double t2 = (-1 * coords[0][0]);
  double t3 = (t2 + coords[1][0]);
  double t4 = (t0 + coords[2][1]);
  double t5 = (t2 + coords[2][0]);
  double t6 = ((t3 * t4) + (-1 * (t5 * t1)));
  double t7 = ((-1 * t1) / t6);
  double t8 = (t4 / t6);
  double t9 = (t3 / t6);
  double t11 = ((-1 * t5) / t6);
\end{minted}
      \end{column}
      \begin{column}{0.5\textwidth}
\begin{minted}[fontsize=\tiny]{c}
  for (int k0 = 0; k0 < 3; k0++) {
    t13[k0] = (t11 * t12[k0]) + (t9 * t10[k0]);
    t14[k0] = (t8 * t12[k0]) + (t7 * t10[k0]);
  }
  double t15 = (0.5 * fabs(t6));
  for (int j0 = 0; j0 < 3; j0++) {
    double t16 = ((t11 * t12[j0])
                  + (t9 * t10[j0]));
    double t17 = ((t8 * t12[j0])
                  + (t7 * t10[j0]));
    for (int k0 = 0; k0 < 3; k0++) {
      A[j0][k0] += t15 * ((t17 * t14[k0])
                          + (t16 * t13[k0]));
    }
  }
}
\end{minted}
      \end{column}
    \end{columns}
  \end{onlyenv}
  \end{overlayarea}
\end{frame}

\begin{frame}
  \frametitle{TSFC: compiler passes}
  \begin{block}{Vectorisation}
    Align and pad data structures, then use intrinsics or rely on C
    compiler.
  \end{block}

  \begin{block}{Loop transformations \& flop reduction}
    Solve ILP problem to drive factorisation, code motion, and common
    subexpression elimination.
  \end{block}

  \begin{block}{Sum factorisation}
    Some finite elements use \emph{tensor product} basis functions
    \begin{equation*}
      \phi_{i,q} := \phi_{(j,k),(p,r)} = \varphi_{j,p}\varphi_{k,r}
    \end{equation*}
    These permit low-complexity algorithms for evaluation of integrals.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Automated, not just for toy problems}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{block}{}
        Find $u \in V \subset H(\curl)$ s.t.
        {\scriptsize \begin{equation*}
          \int\!\!\curl u \cdot \curl v \,\text{d}x = \int\!\!B\cdot
          v\,\text{d}x \quad \forall v \in V.
        \end{equation*}}
\begin{minted}[fontsize=\tiny,mathescape]{python}
NCE = FiniteElement("NCE", hexahedron, degree)
Q = VectorElement("Q", hexahedron, degree)
u = Coefficient(NCE) # Solution in $H(\curl)$
B = Coefficient(Q)   # Coefficient in $H^1$
v = TestFunction(NCE)
F = (dot(curl(u), curl(v)) - dot(B, v))*dx
\end{minted}
    \end{block}
    \end{column}
  \begin{column}{0.6\textwidth}
  \begin{center}
    \begin{tikzpicture}[scale=0.9]
      \begin{loglogaxis}[name=plot, small, title=FLOPs to evaluate $F$,
        xlabel=Polynomial degree,
        ylabel=FLOPs, xtick={1,2,4,8,16,32},
        xticklabels={$1$,$2$,$4$,$8$,$16$,$32$}, axis lines=left, axis
        line style={-}, log basis x=2,
        legend entries={Na\"ive, With sum factorisation},
        legend style={at={(0.5,-0.3)},anchor=north,draw=none}]
        \pgfplotstableread[row sep=crcr]{
degree flops_vanilla flops_opt\\
1 9.78100e+03 6.48100e+03\\
2 1.05624e+05 2.78280e+04\\
3 6.04110e+05 7.50860e+04\\
4 2.36102e+06 1.63395e+05\\
5 7.20724e+06 3.09060e+05\\
6 1.85105e+07 5.33483e+05\\
7 4.18644e+07 8.60322e+05\\
8 8.59101e+07 1.31626e+06\\
9 1.63287e+08 1.93100e+06\\
10 2.91712e+08 2.73728e+06\\
11 4.95190e+08 3.77084e+06\\
12 8.05352e+08 5.07047e+06\\
13 1.26293e+09 6.67796e+06\\
14 1.91933e+09 8.63816e+06\\
15 2.83841e+09 1.09989e+07\\
16 4.09829e+09 1.38110e+07\\
17 5.79335e+09 1.71285e+07\\
18 8.03637e+09 2.10082e+07\\
19 1.09608e+10 2.55101e+07\\
20 1.47229e+10 3.06972e+07\\
21 1.95048e+10 3.66353e+07\\
22 2.55164e+10 4.33937e+07\\
23 3.29987e+10 5.10443e+07\\
24 4.22266e+10 5.96621e+07\\
25 5.35115e+10 6.93253e+07\\
26 6.72053e+10 8.01150e+07\\
27 8.37026e+10 9.21153e+07\\
28 1.03445e+11 1.05413e+08\\
29 1.26924e+11 1.20099e+08\\
30 1.54686e+11 1.36267e+08\\
31 1.87334e+11 1.54011e+08\\
32 2.25533e+11 1.73433e+08\\
}\data; \pgfplotstableset{create on use/vanilla/.style={create
            col/expr={1e3*pow(\thisrow{degree},6)}}};
        \pgfplotstableset{create on use/spectral/.style={create
            col/expr={5e2*pow(\thisrow{degree},4)}}};
  
        \addplot+[mark=none, color=black, line width=1.5pt] table
        [x=degree,y=flops_vanilla] \data; \addplot+[mark=none,
        color=black, dashed, line width=1.5pt] table
        [x=degree,y=flops_opt] \data; \addplot+[mark=none, color=black,
        dotted, line width=1pt] table [x=degree,y=vanilla] \data
        coordinate [pos=0.67] (A); \node at (A) [anchor=south east]
        {$\mathcal{O}(p^6)$}; \addplot+[mark=none, color=black,
        dotted, line width=1pt] table [x=degree,y=spectral] \data
        coordinate [pos=0.67] (B); \node at (B) [anchor=north west]
        {$\mathcal{O}(p^4)$};
      \end{loglogaxis}
    \end{tikzpicture}
  \end{center}    
\end{column}
\end{columns}  
\end{frame}

\begin{frame}
  \frametitle{Application: coastal ocean modelling}
  \begin{center}
    \includegraphics[width=0.45\textwidth]{thetis-rhine} \hspace{1em}
    \includegraphics[width=0.45\textwidth]{selfe-rhine}
  \end{center}
  \begin{block}{New model}
    \begin{itemize}
    \item Better solutions than previous model in group.
    \item 4-8x faster than models with comparative quality of
      results.
    \item Has an adjoint: in use for PDE-constrained optimisation of
      tidal turbine array layout.
    \item Only 1.5 person years.
    \end{itemize}
  \end{block}
\end{frame}
\section{Future research}

\begin{frame}
  \frametitle{High performance solvers}
  \begin{itemize}
  \item In most cases, after discretising a PDE, we need to
    \emph{solve} a (non)linear problem.
  \item Designing robust, scalable solvers is a vast area of research
    in applied mathematics.
  \item Papers often only hack up a matlab proof of concept.
  \end{itemize}
  \begin{block}{Idea}
    \begin{itemize}
    \item Mathematics is the language used to derive optimal solvers.

    \item It \emph{should be} the language we use to describe their implementation.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Challenges}
    \begin{itemize}
    \item How to capture the mathematical building blocks in computer
      code?
    \item What does the compiler for this look like?
    \item How can it be portable across new computer hardware?
    \end{itemize}
  \end{block}
  \begin{block}{Rewards}
    \begin{itemize}
    \item Bring state-of-the-art numerical solvers to the masses.
    \item Cross-fertilisation with programming language design.
    \item Enable more exploratory, and creative, mathematics.
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}
  \frametitle{Summary}
  \begin{itemize}
  \item Broad interdisciplinary research agenda spanning:
    \begin{itemize}
    \item Programming languages
    \item Domain-specific compilers
    \item Numerical methods \& (non)linear algebra
    \end{itemize}
  \item Application areas:
    \begin{itemize}
    \item coastal ocean \& freshwater outflow
    \item renewable energy
    \item numerical weather prediction
    \end{itemize}
  \end{itemize}
\end{frame}


\section{Lecture excerpt}

\begin{frame}
  \begin{definition}
    recursion \emph{noun}

    see: recursion.
  \end{definition}
\end{frame}

\begin{frame}
  \frametitle{Building from the bottom}
  \begin{itemize}
  \item Many problems in computing lend themselves to a recursive
    formulation
  \item Enumerate a few \emph{base} cases, and a general rule
  \end{itemize}

  \begin{uncoverenv}<2->
    \begin{exampleblock}{The Fibonacci sequence: $F_n$}
      \begin{equation*}
        0, 1, 1, 2, 3, 5, 8, 11, \ldots
      \end{equation*}
      \begin{align*}
        \uncover<3->{F_0 &= 0}\\
        \uncover<4->{F_1 &= 1}\\
        \uncover<5->{F_n &= F_{n-1} + F_{n-2} \quad n \ge 2}
      \end{align*}
    \end{exampleblock}
  \end{uncoverenv}
\end{frame}

\begin{frame}
  \frametitle{Computing $F_n$}
  \begin{algorithmic}
    \Require $n \ge 0$ and $n$ integer
    \Function {Fibonacci}{$n$} \Comment{The $n^{\text{th}}$ Fibonacci number}
    \If {$n = 0$}
    \State \Return 0
    \ElsIf {$n = 1$}
    \State \Return 1
    \Else
    \State \Return $\textsc{Fibonacci}(n-1) + \textsc{Fibonacci}(n-2)$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \begin{align*}
    F_0 &= 0\\
    F_1 &= 1\\
    F_n &= F_{n-1} + F_{n-2} \quad n \ge 2
  \end{align*}
\end{frame}

\begin{frame}
  \frametitle{Would you use this approach?}
  \begin{itemize}
  \item<1-> To compute $F_1$?
  \item<2-> How about $F_{10}$?
  \item<3-> or $F_{50}$?
  \end{itemize}

  \begin{uncoverenv}<4->
    \begin{center}
      \begin{tikzpicture}
        \begin{semilogyaxis}[name=plot, small, xlabel=$n$, ylabel=Time
          (seconds), axis lines=left, minor tick style={draw=none}]
          \pgfplotstableread[row sep=crcr]{%
            n Fn time        \\
            0 0 2.86102294921875e-06\\
            1 1 1.1920928955078125e-06\\
            2 1 3.0994415283203125e-06\\
            3 2 2.6226043701171875e-06\\
            4 3 3.5762786865234375e-06\\
            5 5 6.4373016357421875e-06\\
            6 8 7.867813110351562e-06\\
            7 13 1.1682510375976562e-05\\
            8 21 1.9550323486328125e-05\\
            9 34 2.9087066650390625e-05\\
            10 55 4.792213439941406e-05\\
            11 89 7.43865966796875e-05\\
            12 144 0.0001220703125\\
            13 233 0.0001957416534423828\\
            14 377 0.0003230571746826172\\
            15 610 0.0005202293395996094\\
            16 987 0.0008740425109863281\\
            17 1597 0.001361846923828125\\
            18 2584 0.0022258758544921875\\
            19 4181 0.003432035446166992\\
            20 6765 0.0054264068603515625\\
            21 10946 0.008519172668457031\\
            22 17711 0.012994766235351562\\
            23 28657 0.019325733184814453\\
            24 46368 0.027605772018432617\\
            25 75025 0.03979802131652832\\
            26 121393 0.055405378341674805\\
            27 196418 0.08416867256164551\\
            28 317811 0.1363823413848877\\
            29 514229 0.22415399551391602\\
            30 832040 0.3448293209075928\\
            31 1346269 0.46398353576660156\\
            32 2178309 0.7304978370666504\\
            33 3524578 1.1890404224395752\\
            34 5702887 1.91109037399292\\
            35 9227465 3.1095051765441895\\
            36 14930352 5.002750396728516\\
            37 24157817 8.09918761253357\\
            38 39088169 13.246513366699219\\
            39 63245986 21.432729244232178\\
            40 102334155 34.87051010131836\\
          }\data; \addplot+[mark=none, color=black, line width=1.5pt]
          table [x=n,y=time] \data;
        \end{semilogyaxis}
      \end{tikzpicture}
    \end{center}
  \end{uncoverenv}
\end{frame}

\begin{frame}
  \frametitle{Memoise, memoise, memoise}
  \begin{itemize}
  \item<1-> We do far too much work!
  \item<2-> Let's draw the call tree for $F_5$
  \item<3-> At each level, we split in two, and recurse
  \item<4-> There are approximately $n$ levels.
  \item<5-> So this does around $2^n$ calculations
  \item<6-> But many of them are the same, so why not remember them?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{An improved algorithm}
  \begin{onlyenv}<1>
    \begin{algorithmic}
      \Require $n \ge 0$ and $n$ integer
      \Function {Fibonacci}{$n$, table} \Comment{The $n^{\text{th}}$ Fibonacci number}
      \If {$n < 2$}
      \State \Return $n$
      \ElsIf {$n \in \text{table}$}
      \State \Return $\text{table}[n]$
      \Else
      \State $F \gets \textsc{Fibonacci}(n-1, \text{table}) + \textsc{Fibonacci}(n-2, \text{table})$
      \State $\text{table}[n] \gets F$
      \State \Return $F$ \EndIf
      \EndFunction
    \end{algorithmic}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{columns}
      \begin{column}{0.5\textwidth}
      \begin{tikzpicture}[scale=0.8]
        \begin{axis}[name=plot, small, xlabel=$n$, ylabel=Time
          (seconds), axis lines=left, minor tick style={draw=none},
          title=Original]
          \pgfplotstableread[row sep=crcr]{%
            n Fn time        \\
            0 0 2.86102294921875e-06\\
            1 1 1.1920928955078125e-06\\
            2 1 3.0994415283203125e-06\\
            3 2 2.6226043701171875e-06\\
            4 3 3.5762786865234375e-06\\
            5 5 6.4373016357421875e-06\\
            6 8 7.867813110351562e-06\\
            7 13 1.1682510375976562e-05\\
            8 21 1.9550323486328125e-05\\
            9 34 2.9087066650390625e-05\\
            10 55 4.792213439941406e-05\\
            11 89 7.43865966796875e-05\\
            12 144 0.0001220703125\\
            13 233 0.0001957416534423828\\
            14 377 0.0003230571746826172\\
            15 610 0.0005202293395996094\\
            16 987 0.0008740425109863281\\
            17 1597 0.001361846923828125\\
            18 2584 0.0022258758544921875\\
            19 4181 0.003432035446166992\\
            20 6765 0.0054264068603515625\\
            21 10946 0.008519172668457031\\
            22 17711 0.012994766235351562\\
            23 28657 0.019325733184814453\\
            24 46368 0.027605772018432617\\
            25 75025 0.03979802131652832\\
            26 121393 0.055405378341674805\\
            27 196418 0.08416867256164551\\
            28 317811 0.1363823413848877\\
            29 514229 0.22415399551391602\\
            30 832040 0.3448293209075928\\
            31 1346269 0.46398353576660156\\
            32 2178309 0.7304978370666504\\
            33 3524578 1.1890404224395752\\
            34 5702887 1.91109037399292\\
            35 9227465 3.1095051765441895\\
            36 14930352 5.002750396728516\\
            37 24157817 8.09918761253357\\
            38 39088169 13.246513366699219\\
            39 63245986 21.432729244232178\\
            40 102334155 34.87051010131836\\
          }\data; \addplot+[mark=none, color=black, line width=1.5pt]
          table [x=n,y=time] \data;
        \end{axis}
      \end{tikzpicture}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{tikzpicture}[scale=0.8]
          \begin{axis}[name=plot, small, xlabel=$n$, ylabel=Time
            (seconds), axis lines=left, minor tick style={draw=none},
            title=With lookup table]
            \pgfplotstableread[row sep=crcr]{%
              n time\\
              0 1.4781951904296875e-05\\
              100 0.00013709068298339844\\
              200 0.00020241737365722656\\
              300 0.0002853870391845703\\
              400 0.0003566741943359375\\
              500 0.00045180320739746094\\
              600 0.0005140304565429688\\
              700 0.0006868839263916016\\
              800 0.0007913112640380859\\
              900 0.0008821487426757812\\
              1000 0.0009739398956298828\\
              1100 0.0010683536529541016\\
              1200 0.0011439323425292969\\
              1300 0.001230001449584961\\
              1400 0.0013885498046875\\
              1500 0.001459360122680664\\
              1600 0.0014569759368896484\\
              1700 0.0013935565948486328\\
              1800 0.001417398452758789\\
              1900 0.001462697982788086\\
              2000 0.0016179084777832031\\
              2100 0.0015850067138671875\\
              2200 0.0017046928405761719\\
              2300 0.001983642578125\\
              2400 0.0017900466918945312\\
              2500 0.0018372535705566406\\
              2600 0.0018715858459472656\\
              2700 0.002187967300415039\\
              2800 0.0022695064544677734\\
              2900 0.002347707748413086\\
              3000 0.0024483203887939453\\
              3100 0.0025606155395507812\\
              3200 0.002579212188720703\\
              3300 0.0026204586029052734\\
              3400 0.0026786327362060547\\
              3500 0.0029387474060058594\\
              3600 0.002973318099975586\\
              3700 0.0030701160430908203\\
              3800 0.0030930042266845703\\
              3900 0.003291606903076172\\
              4000 0.003585338592529297\\
              4100 0.0035524368286132812\\
              4200 0.003659963607788086\\
              4300 0.003890514373779297\\
              4400 0.004056453704833984\\
              4500 0.0038678646087646484\\
              4600 0.00389862060546875\\
              4700 0.003849029541015625\\
              4800 0.004190206527709961\\
              4900 0.004049539566040039\\
              5000 0.004136562347412109\\
            }\data; \addplot+[mark=none, color=black, line
            width=1.5pt] table [x=n,y=time] \data;
          \end{axis}
        \end{tikzpicture}
      \end{column}
    \end{columns}
    \begin{itemize}
    \item Now we only calculate each $F_n$ once.
    \item So runtime is now proportional to $n$.  At the cost of
      storing $n$ values.
    \item Challenge: is this the best you can do?
    \end{itemize}
  \end{onlyenv}
\end{frame}

\begin{frame}
  \frametitle{What's in a name?}
  \begin{itemize}
  \item This trick, replacing repeated computation by a lookup of the
    result, is called \emph{dynamic programming}.
  \item Coined by Richard Bellman in the 1950s
  \end{itemize}
  \begin{quote}
    dynamic {\normalfont[\ldots]} has a very interesting property as an adjective,
    {\normalfont[\ldots]} it's impossible to use the word dynamic in a pejorative
    sense.
  \end{quote}
\end{frame}
% \begin{frame}
%   \frametitle{Overview}
%   \begin{itemize}
%   \item Some cautionary tales
%   \item How computers represent numbers
%   \item Difficulties due to finite range/precision
%   \item Numerical \emph{conditioning} and how to tell when you have
%     nonsense answers
%   \end{itemize}
% \end{frame}

% \begin{frame}[plain,t]
%   \begin{flushright}
%       \tiny CC BY-SA 3.0
%       \url{https://commons.wikimedia.org/wiki/File:Boeing_787_Roll-out.jpg}
%   \end{flushright}
%   \begin{tikzpicture}[remember picture, overlay]
%     \node[at=(current page.center)] (dreamliner)
%     {\includegraphics[width=\paperwidth]{dreamliner}};
%     \uncover<2->{\node [below right=1cm of dreamliner.north west, anchor=north west]
%       {\includegraphics[width=1\framewidth]{dreamliner-bug-2015}};}
%     \uncover<3->{\node [above left=1cm of dreamliner.south east, anchor=south east]
%       {\includegraphics[width=1\framewidth]{dreamliner-bug-2016}};}
%   \end{tikzpicture}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{The pernicious \texttt{int}}
%   Integers are represented either \emph{signed} or \emph{unsigned}
%   using a fixed number of \emph{bits}.

%   Let's try computing $127+1$, represented as 8bit signed integers.

%   \begin{uncoverenv}<2>
%   \begin{tikzpicture}
%     \matrix (m) [matrix of nodes,
%     nodes={minimum size=0.75cm, draw, anchor=center},
%     column sep=0pt,
%     ]
%     { $-2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$
%       \\};
%     \matrix (mfull) [matrix of nodes, below=0.2cm of m,
%     nodes={minimum size=0.75cm, draw, anchor=center},
%     column sep=0pt,
%     ]
%     { $0$ & $1$ & $1$ & $1$ & $1$ & $1$ & $1$ & $1$
%       \\};
%     \node [left=0.1cm of mfull]  {$127$};
%     \matrix (mone) [matrix of nodes, below=0.2cm of mfull,
%     nodes={minimum size=0.75cm, draw, anchor=center},
%     column sep=0pt,
%     ]
%     { $0$ & $0$ & $0$ & $0$ & $0$ & $0$ & $0$ & $1$
%       \\};
%     \node [left=0.1cm of mone] {$1$};
%     \node [above left=0.1cm and 0.3cm of mone.north west, anchor=center] {$+$};

%     \matrix (moops) [matrix of nodes, below=0.2cm of mone,
%     nodes={minimum size=0.75cm, draw, anchor=center},
%     column sep=0pt,
%     ]
%     { $1$ & $0$ & $0$ & $0$ & $0$ & $0$ & $0$ & $0$
%       \\};
%     \node [left=0.1cm of moops] {$-128$};
%     \node [above left=0.1cm and 0.3cm of moops.north west,
%     anchor=center] {$=$};
%     \node [right=0.1cm of moops] {(Probably)};
%   \end{tikzpicture}
%   \end{uncoverenv}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{The pernicious \texttt{int}}
%   Let's go back and look at the Dreamliner numbers again.

%   \begin{equation*}
%     248\,\text{days} = 248 \times 24 \times 3600 \times 100 =
%     2142720000 \,\text{centiseconds}
%   \end{equation*}
%   \begin{equation*}
%     22\,\text{days} = 22 \times 24 \times 3600 \times 1000 =
%     1900800000 \,\text{milliseconds}
%   \end{equation*}


%   \begin{uncoverenv}<2>
%     \begin{equation*}
%       \log_2{2142720000} \approx 30.997
%     \end{equation*}
%   \begin{equation*}
%     \log_2{1900800000} \approx 30.824
%   \end{equation*}

%   Both of these failures are almost certainly due to \emph{integer
%     overflow} of a signed 32bit integer.
% \end{uncoverenv}
% \end{frame}

% \begin{frame}
%   \frametitle{Should you trust your calculation?}

%   Computing with real values provides a whole new class of ways to get
%   the wrong answer.

%   \begin{center}
%     \includegraphics[height=0.6\textheight]{vancouver-index}
%   \end{center}
%   \begin{flushright}
%     {\scriptsize McCullogh \& Vinod, Journal of Economic Literature
%     37(2):633--665 (1999)}
%   \end{flushright}
% \end{frame}

% \begin{frame}
%   \frametitle{Floating point}
%   \begin{itemize}
%   \item The set of real numbers is uncountable, which presents
%     problems on a computer.
%   \item We typically approximate real numbers using \emph{floating
%       point}.
%   \item Scientific notation with a fixed number of
%     \emph{significant figures}
%   \end{itemize}
%   \begin{equation*}
%     1015323 = \underbrace{1.015323}_{\text{significand}} \times \underbrace{10}_{\text{base}}\!\!\!\!\!\!^{\overbrace{6}^{\text{exponent}}}
%   \end{equation*}
% \end{frame}

% \begin{frame}
%   \frametitle{Floating point}
%   \begin{itemize}
%   \item Behaviour implemented in CPUs standardised in IEEE 754
%   \item Specifies how to interpret bit patterns as floating point
%     numbers
%   \item Also specifies \emph{rounding} for calculations that result in
%     values that not exactly representable
%   \item Defines \emph{base} to be 2.
%   \end{itemize}
%   \begin{tabular}{c|ccc|c}
%     Precision & Sign & Exponent & Significand & Total bits \\
%     \hline
%     single    & 1    & 8        & 23          & 32         \\
%     double    & 1    & 11       & 52          & 64         \\
%   \end{tabular}
% \end{frame}

% \begin{frame}
%   \frametitle{Bit representation}
%   \begin{tikzpicture}
%     \node[rectangle,draw,inner sep=0pt, minimum width=1cm, minimum
%     height=0.5cm, anchor=west] at (0, 0) (sign) {sign};
%     \node[rectangle,draw,inner sep=0pt, minimum width=3cm, minimum
%     height=0.5cm, anchor=west] at (1cm, 0) (exp) {exponent};
%     \node[rectangle,draw,inner sep=0pt, minimum width=5cm, minimum
%     height=0.5cm, anchor=west] at (4cm, 0) (sig) {significand};
%     \node[left=0.1cm of sign.west] {$\text{val} = $};

%     \node[above=0cm of sign.north west] {32};
%     \node[above=0cm of sign.north east] {31};
%     \node[above=0cm of exp.north east] {23};
%     \node[above=0cm of sig.north east] {0};
%   \end{tikzpicture}
%   \begin{equation*}
%     f = \begin{cases}
%       \phantom{-}1.sssssssss_2 \times 2^{\text{exp}} & \text{sign} = 0\\
%       -1.sssssssss_2 \times 2^{\text{exp}} & \text{sign} = 1\\
%      \end{cases}
%    \end{equation*}
%    note ``hidden'' bit of precision, so
%    \begin{equation*}
%      f = (1 + \sum_{i=1}^{23} \text{val}_{i-1} * 2^{-i})\times 2^{\text{exp}}
%    \end{equation*}
% \end{frame}

% \begin{frame}
%   \frametitle{What about zero?}
%   \begin{itemize}
%   \item We need to play some tricks, and do so by stealing some bits
%     in the exponent.
%   \end{itemize}
%   \begin{center}
%     {\small
%       \begin{tabular}{c|c|c}
%         \multicolumn{2}{c|}{Exponent} & Value represented\\
%         Binary & Decimal & \\
%         \hline
%         $00000000_2$ & $0_{10}$ & Zero if significand is zero \\
%         $00000001_2$ & $1_{10}$ & $1.sssssssss_2 \times 2^{-126}$ \\
%         \dots & \dots & \dots \\
%         $01111111_2$ & $127_{10}$ & $1.sssssssss_2 \times 2^{-0}$ \\
%         $10000000_2$ & $128_{10}$ & $1.sssssssss_2 \times 2^{1}$ \\
%         \dots & \dots & \dots \\
%         $11111110_2$ & $254_{10}$ & $1.sssssssss_2 \times 2^{127}$ \\
%         $11111111_2$ & $255_{10}$ & $\infty$ if significand is zero\\
%       \end{tabular}
%     }
%   \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Almost all numbers are represented inexactly}
%   \begin{itemize}
%   \item Any irrational number ($\sqrt{2}, \pi, \dots$) is not exact in
%     floating point
%   \item But many rational numbers are also not (after all they are
%     countable, but still infinite).
%   \item In the same way that $1/3$ is $0.333\overline{33}_{10}$.
%   \item $0.1 = 0.0001100\overline{1100}_2$
%   \item The result of a calculation may not be the closest
%     representable number to the exact result!
%   \end{itemize}
%   \begin{center}
% \begin{minted}[fontsize=\small]{c}
% print 0.01f - (0.1f*0.1f); => -9.31323e-10
% \end{minted}
%   \end{center}
% \end{frame}

% \begin{frame}
%   \frametitle{Addition}
%   \begin{itemize}
%   \item How to add two numbers with different scales?
%     \begin{equation*}
%       1 \times 10^{6} + 2
%     \end{equation*}
%   \item \emph{Shift} so exponent is the same
%   \item add significands
%     \begin{align*}
%       1 \times 10^{6} + 2 &= \\
%       1 \times 10^{6} + 0.000002 \times 10^{6} &= \\
%       1.000002 \times 10^{6}
%     \end{align*}
%   \item What happens if there are not enough bits in the significand?
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{No associativity}
%   We expect that arithmetic operations \emph{associate}
%   \begin{equation*}
%     (a + b) - c = a + (b - c).
%   \end{equation*}

%   Floating point operations do not.

%     \begin{center}
%       \begin{onlyenv}<2>
% \begin{minted}[fontsize=\small]{c}
% print ((1f + 1e10f) - 1e10f);
% print (1f + (1e10f - 1e10f));
% \end{minted}
%       \end{onlyenv}
%     \end{center}
%     \begin{center}
%       \begin{onlyenv}<3>
% \begin{minted}[fontsize=\small]{c}
% print ((1f + 1e10f) - 1e10f); => 0.0f
% print (1f + (1e10f - 1e10f)); => 1.0f
% \end{minted}
%       \end{onlyenv}
%     \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{No distributivity}
%   We expect that multiplication \emph{distributes} over addition
%   \begin{equation*}
%     (a + b)*c = a*c + b*c
%   \end{equation*}

%   Again, this does not occur in floating point.

%   \begin{center}
%     \begin{uncoverenv}<2>
% \begin{minted}[fontsize=\small]{c}
% float a = 1234.5678f;
% float b = 1.2345678f;
% float c = 3.3333333f;
% print (a+b)*c; => 4119.3413f
% print (a*c) + (b*c); => 4119.3408f
% \end{minted}
%     \end{uncoverenv}
%   \end{center}
% \end{frame}

% \begin{frame}
%   \frametitle{Sensitivity of numerical algorithms}
%   \begin{itemize}
%   \item The study of the accuracy and stability of numerical algorithms is as old
%     as computers.
%   \item Concerned with how errors propagate through an algorithm.
%   \item A core concept here is \emph{conditioning}.
%   \end{itemize}

%   Intuitively, conditioning tells us how sensitive the output of a
%   function is to small changes in its inputs.
% \end{frame}

\end{document}
